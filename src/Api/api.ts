/* tslint:disable */
/* eslint-disable */
/**
 * hmsidm-backend
 * Backend API for hmsidm service
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface Certificate
 */
export interface Certificate {
  /**
   *
   * @type {string}
   * @memberof Certificate
   */
  issuer: string;
  /**
   *
   * @type {string}
   * @memberof Certificate
   */
  nickname: string;
  /**
   *
   * @type {string}
   * @memberof Certificate
   */
  not_after: string;
  /**
   *
   * @type {string}
   * @memberof Certificate
   */
  not_before: string;
  /**
   *
   * @type {string}
   * @memberof Certificate
   */
  pem: string;
  /**
   *
   * @type {string}
   * @memberof Certificate
   */
  serial_number: string;
  /**
   *
   * @type {string}
   * @memberof Certificate
   */
  subject: string;
}
/**
 * A domain resource
 * @export
 * @interface CreateDomain
 */
export interface CreateDomain {
  /**
   * the title for the entry
   * @type {string}
   * @memberof CreateDomain
   */
  title: string;
  /**
   * Human readable description for this domain.
   * @type {string}
   * @memberof CreateDomain
   */
  description: string;
  /**
   * Enable or disable host vm auto-enrollment for this domain
   * @type {boolean}
   * @memberof CreateDomain
   */
  auto_enrollment_enabled: boolean;
  /**
   *
   * @type {DomainType}
   * @memberof CreateDomain
   */
  domain_type: DomainType;
}

/**
 * Options for ipa domains
 * @export
 * @interface CreateDomainIpa
 */
export interface CreateDomainIpa {
  /**
   * List of auto-enrollment enabled servers for this domain.
   * @type {Array<CreateDomainIpaServer>}
   * @memberof CreateDomainIpa
   */
  servers?: Array<CreateDomainIpaServer>;
  /**
   * A base64 representation of all the list of chain of certificates, including the server ca.
   * @type {Array<Certificate>}
   * @memberof CreateDomainIpa
   */
  ca_certs: Array<Certificate>;
  /**
   * TODO What is the meaning of this field.
   * @type {Array<string>}
   * @memberof CreateDomainIpa
   */
  realm_domains: Array<string>;
  /**
   * A Kerberos realm name (usually all upper-case domain name)
   * @type {string}
   * @memberof CreateDomainIpa
   */
  realm_name: string;
}
/**
 * Server schema for an entry into the Ipa domain type
 * @export
 * @interface CreateDomainIpaServer
 */
export interface CreateDomainIpaServer {
  /**
   *
   * @type {boolean}
   * @memberof CreateDomainIpaServer
   */
  ca_server: boolean;
  /**
   * A host\'s Fully Qualified Domain Name (all lower-case).
   * @type {string}
   * @memberof CreateDomainIpaServer
   */
  fqdn: string;
  /**
   *
   * @type {boolean}
   * @memberof CreateDomainIpaServer
   */
  hcc_enrollment_server: boolean;
  /**
   *
   * @type {boolean}
   * @memberof CreateDomainIpaServer
   */
  hcc_update_server: boolean;
  /**
   *
   * @type {boolean}
   * @memberof CreateDomainIpaServer
   */
  pkinit_server: boolean;
  /**
   * A Red Hat Subcription Manager ID of a RHEL host.
   * @type {string}
   * @memberof CreateDomainIpaServer
   */
  subscription_manager_id: string;
}
/**
 * A domain resource
 * @export
 * @interface Domain
 */
export interface Domain {
  /**
   * Title to describe the domain.
   * @type {string}
   * @memberof Domain
   */
  title?: string;
  /**
   * Human readable description abou the domain.
   * @type {string}
   * @memberof Domain
   */
  description?: string;
  /**
   * Enable or disable host vm auto-enrollment for this domain
   * @type {boolean}
   * @memberof Domain
   */
  auto_enrollment_enabled?: boolean;
  /**
   * A domain id
   * @type {string}
   * @memberof Domain
   */
  domain_id?: string;
  /**
   * A name of a domain (all lower-case)
   * @type {string}
   * @memberof Domain
   */
  domain_name: string;
  /**
   *
   * @type {DomainType}
   * @memberof Domain
   */
  domain_type: DomainType;
  /**
   *
   * @type {DomainIpa}
   * @memberof Domain
   */
  'rhel-idm'?: DomainIpa;
  /**
   *
   * @type {SigningKeys}
   * @memberof Domain
   */
  signing_keys?: SigningKeys;
}

/**
 * Options for ipa domains
 * @export
 * @interface DomainIpa
 */
export interface DomainIpa {
  /**
   * List of auto-enrollment enabled servers for this domain.
   * @type {Array<DomainIpaServer>}
   * @memberof DomainIpa
   */
  servers: Array<DomainIpaServer>;
  /**
   * A base64 representation of all the list of chain of certificates, including the server ca.
   * @type {Array<Certificate>}
   * @memberof DomainIpa
   */
  ca_certs: Array<Certificate>;
  /**
   * List of allowed locations
   * @type {Array<DomainIpaLocationsInner>}
   * @memberof DomainIpa
   */
  locations?: Array<DomainIpaLocationsInner>;
  /**
   * List of realm associated to the IPA domain.
   * @type {Array<string>}
   * @memberof DomainIpa
   */
  realm_domains: Array<string>;
  /**
   * A Kerberos realm name (usually all upper-case domain name)
   * @type {string}
   * @memberof DomainIpa
   */
  realm_name: string;
}
/**
 *
 * @export
 * @interface DomainIpaLocationsInner
 */
export interface DomainIpaLocationsInner {
  /**
   * A location identifier (lower-case DNS label)
   * @type {string}
   * @memberof DomainIpaLocationsInner
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof DomainIpaLocationsInner
   */
  description?: string;
}
/**
 * Server schema for an entry into the Ipa domain type.
 * @export
 * @interface DomainIpaServer
 */
export interface DomainIpaServer {
  /**
   *
   * @type {boolean}
   * @memberof DomainIpaServer
   */
  ca_server: boolean;
  /**
   * A host\'s Fully Qualified Domain Name (all lower-case).
   * @type {string}
   * @memberof DomainIpaServer
   */
  fqdn: string;
  /**
   *
   * @type {boolean}
   * @memberof DomainIpaServer
   */
  hcc_enrollment_server: boolean;
  /**
   *
   * @type {boolean}
   * @memberof DomainIpaServer
   */
  hcc_update_server: boolean;
  /**
   * A location identifier (lower-case DNS label)
   * @type {string}
   * @memberof DomainIpaServer
   */
  location?: string;
  /**
   *
   * @type {boolean}
   * @memberof DomainIpaServer
   */
  pkinit_server: boolean;
  /**
   * A Red Hat Subcription Manager ID of a RHEL host.
   * @type {string}
   * @memberof DomainIpaServer
   */
  subscription_manager_id?: string;
}
/**
 * Type of domain (currently only rhel-idm)
 * @export
 * @enum {string}
 */

export const DomainType = {
  RhelIdm: 'rhel-idm',
} as const;

export type DomainType = (typeof DomainType)[keyof typeof DomainType];

/**
 *
 * @export
 * @interface ErrorInfo
 */
export interface ErrorInfo {
  /**
   * The human-readable HTTP status text for the error.
   * @type {string}
   * @memberof ErrorInfo
   */
  title: string;
  /**
   * an application-specific error code
   * @type {string}
   * @memberof ErrorInfo
   */
  code?: string;
  /**
   * A detailed explanation of the error, e.g. traceback.
   * @type {string}
   * @memberof ErrorInfo
   */
  detail?: string;
  /**
   * a unique identifier for this particular occurrence of the problem.
   * @type {string}
   * @memberof ErrorInfo
   */
  id: string;
  /**
   * The HTTP status code for the error.
   * @type {string}
   * @memberof ErrorInfo
   */
  status: string;
}
/**
 * General error response returned by the hmsidm API
 * @export
 * @interface Errors
 */
export interface Errors {
  /**
   * Error objects provide additional information about problems encountered while performing an operation.
   * @type {Array<ErrorInfo>}
   * @memberof Errors
   */
  errors: Array<ErrorInfo>;
}
/**
 * Represent the request payload for the /hostconf/:fqdn endpoint.
 * @export
 * @interface HostConf
 */
export interface HostConf {
  /**
   * A domain id
   * @type {string}
   * @memberof HostConf
   */
  domain_id?: string;
  /**
   * A name of a domain (all lower-case)
   * @type {string}
   * @memberof HostConf
   */
  domain_name?: string;
  /**
   *
   * @type {DomainType}
   * @memberof HostConf
   */
  domain_type?: DomainType;
}

/**
 * Options for ipa domains
 * @export
 * @interface HostConfIpa
 */
export interface HostConfIpa {
  /**
   * A string of concatenated, PEM-encoded X.509 certificates
   * @type {string}
   * @memberof HostConfIpa
   */
  cabundle: string;
  /**
   * List of auto-enrollment enabled servers for this domain.
   * @type {Array<HostConfIpaEnrollmentServersInner>}
   * @memberof HostConfIpa
   */
  enrollment_servers?: Array<HostConfIpaEnrollmentServersInner>;
  /**
   * A Kerberos realm name (usually all upper-case domain name)
   * @type {string}
   * @memberof HostConfIpa
   */
  realm_name?: string;
}
/**
 *
 * @export
 * @interface HostConfIpaEnrollmentServersInner
 */
export interface HostConfIpaEnrollmentServersInner {
  /**
   * A host\'s Fully Qualified Domain Name (all lower-case).
   * @type {string}
   * @memberof HostConfIpaEnrollmentServersInner
   */
  fqdn: string;
  /**
   * A location identifier (lower-case DNS label)
   * @type {string}
   * @memberof HostConfIpaEnrollmentServersInner
   */
  location?: string;
}
/**
 * The response for the action to retrieve the host vm information when it is being enrolled. This action is taken from the host vm.
 * @export
 * @interface HostConfResponseSchema
 */
export interface HostConfResponseSchema {
  /**
   * Enable or disable host vm auto-enrollment for this domain
   * @type {boolean}
   * @memberof HostConfResponseSchema
   */
  auto_enrollment_enabled: boolean;
  /**
   * A domain id
   * @type {string}
   * @memberof HostConfResponseSchema
   */
  domain_id: string;
  /**
   * A name of a domain (all lower-case)
   * @type {string}
   * @memberof HostConfResponseSchema
   */
  domain_name: string;
  /**
   *
   * @type {DomainType}
   * @memberof HostConfResponseSchema
   */
  domain_type: DomainType;
  /**
   * A Host-Based Inventory ID of a host.
   * @type {string}
   * @memberof HostConfResponseSchema
   */
  inventory_id: string;
  /**
   *
   * @type {HostConfResponseSchemaRhelIdm}
   * @memberof HostConfResponseSchema
   */
  'rhel-idm': HostConfResponseSchemaRhelIdm;
  /**
   * A serialized JWS token or JWT to authenticate a host registration request.
   * @type {string}
   * @memberof HostConfResponseSchema
   */
  token?: string;
}

/**
 *
 * @export
 * @interface HostConfResponseSchemaRhelIdm
 */
export interface HostConfResponseSchemaRhelIdm {
  /**
   * A string of concatenated, PEM-encoded X.509 certificates
   * @type {string}
   * @memberof HostConfResponseSchemaRhelIdm
   */
  cabundle: string;
  /**
   * List of auto-enrollment enabled servers for this domain.
   * @type {Array<HostConfIpaEnrollmentServersInner>}
   * @memberof HostConfResponseSchemaRhelIdm
   */
  enrollment_servers: Array<HostConfIpaEnrollmentServersInner>;
  /**
   * A Kerberos realm name (usually all upper-case domain name)
   * @type {string}
   * @memberof HostConfResponseSchemaRhelIdm
   */
  realm_name: string;
}
/**
 * The data listed for the domains.
 * @export
 * @interface ListDomainsData
 */
export interface ListDomainsData {
  /**
   * Human-friendly title for the domain entry.
   * @type {string}
   * @memberof ListDomainsData
   */
  title: string;
  /**
   * Human-readable description of the domain entry.
   * @type {string}
   * @memberof ListDomainsData
   */
  description: string;
  /**
   *
   * @type {boolean}
   * @memberof ListDomainsData
   */
  auto_enrollment_enabled: boolean;
  /**
   * A domain id
   * @type {string}
   * @memberof ListDomainsData
   */
  domain_id: string;
  /**
   * A name of a domain (all lower-case)
   * @type {string}
   * @memberof ListDomainsData
   */
  domain_name: string;
  /**
   *
   * @type {DomainType}
   * @memberof ListDomainsData
   */
  domain_type: DomainType;
}

/**
 * Represent a paginated result for a list of domains
 * @export
 * @interface ListDomainsResponseSchema
 */
export interface ListDomainsResponseSchema {
  /**
   * The content for this page.
   * @type {Array<ListDomainsData>}
   * @memberof ListDomainsResponseSchema
   */
  data: Array<ListDomainsData>;
  /**
   *
   * @type {PaginationLinks}
   * @memberof ListDomainsResponseSchema
   */
  links: PaginationLinks;
  /**
   *
   * @type {PaginationMeta}
   * @memberof ListDomainsResponseSchema
   */
  meta: PaginationMeta;
}
/**
 * Represent the navigation links for the data paginated.
 * @export
 * @interface PaginationLinks
 */
export interface PaginationLinks {
  /**
   * Reference to the first page of the request.
   * @type {string}
   * @memberof PaginationLinks
   */
  first?: string;
  /**
   * Reference to the last page of the request.
   * @type {string}
   * @memberof PaginationLinks
   */
  last?: string;
  /**
   * Reference to the next page of the request.
   * @type {string}
   * @memberof PaginationLinks
   */
  next?: string;
  /**
   * Reference to the previous page of the request.
   * @type {string}
   * @memberof PaginationLinks
   */
  previous?: string;
}
/**
 * Metadata for the paginated responses.
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
  /**
   * total records in the collection.
   * @type {number}
   * @memberof PaginationMeta
   */
  count: number;
  /**
   * Number of items per page.
   * @type {number}
   * @memberof PaginationMeta
   */
  limit: number;
  /**
   * Initial record of the page.
   * @type {number}
   * @memberof PaginationMeta
   */
  offset: number;
}
/**
 * A domain resource
 * @export
 * @interface RegisterDomain
 */
export interface RegisterDomain {
  /**
   * Title to describe the domain.
   * @type {string}
   * @memberof RegisterDomain
   */
  title?: string;
  /**
   * Human readable description abou the domain.
   * @type {string}
   * @memberof RegisterDomain
   */
  description?: string;
  /**
   * Enable or disable host vm auto-enrollment for this domain
   * @type {boolean}
   * @memberof RegisterDomain
   */
  auto_enrollment_enabled?: boolean;
  /**
   * A domain id
   * @type {string}
   * @memberof RegisterDomain
   */
  domain_id?: string;
  /**
   * A name of a domain (all lower-case)
   * @type {string}
   * @memberof RegisterDomain
   */
  domain_name: string;
  /**
   *
   * @type {DomainType}
   * @memberof RegisterDomain
   */
  domain_type: DomainType;
  /**
   *
   * @type {DomainIpa}
   * @memberof RegisterDomain
   */
  'rhel-idm'?: DomainIpa;
  /**
   *
   * @type {SigningKeys}
   * @memberof RegisterDomain
   */
  signing_keys?: SigningKeys;
}

/**
 * A domain resource
 * @export
 * @interface ResponseDomain
 */
export interface ResponseDomain {
  /**
   * Title to describe the domain.
   * @type {string}
   * @memberof ResponseDomain
   */
  title?: string;
  /**
   * Human readable description abou the domain.
   * @type {string}
   * @memberof ResponseDomain
   */
  description?: string;
  /**
   * Enable or disable host vm auto-enrollment for this domain
   * @type {boolean}
   * @memberof ResponseDomain
   */
  auto_enrollment_enabled?: boolean;
  /**
   * A domain id
   * @type {string}
   * @memberof ResponseDomain
   */
  domain_id?: string;
  /**
   * A name of a domain (all lower-case)
   * @type {string}
   * @memberof ResponseDomain
   */
  domain_name: string;
  /**
   *
   * @type {DomainType}
   * @memberof ResponseDomain
   */
  domain_type: DomainType;
  /**
   *
   * @type {DomainIpa}
   * @memberof ResponseDomain
   */
  'rhel-idm'?: DomainIpa;
  /**
   *
   * @type {SigningKeys}
   * @memberof ResponseDomain
   */
  signing_keys?: SigningKeys;
}

/**
 * Represent a rhel-idm token which allow register the domain information.
 * @export
 * @interface RhelIdmToken
 */
export interface RhelIdmToken {
  /**
   *
   * @type {string}
   * @memberof RhelIdmToken
   */
  expiration?: string;
  /**
   *
   * @type {string}
   * @memberof RhelIdmToken
   */
  secret?: string;
}
/**
 * Serialized JWKs with revocation information
 * @export
 * @interface SigningKeys
 */
export interface SigningKeys {
  /**
   * An array of serialized JSON Web Keys (JWK strings)
   * @type {Array<string>}
   * @memberof SigningKeys
   */
  keys: Array<string>;
  /**
   * An array of revoked key identifiers (JWK kid)
   * @type {Array<string>}
   * @memberof SigningKeys
   */
  revoked_kids?: Array<string>;
}
/**
 * Update a domain resource
 * @export
 * @interface UpdateDomain
 */
export interface UpdateDomain {
  /**
   * Title to describe the domain.
   * @type {string}
   * @memberof UpdateDomain
   */
  title?: string;
  /**
   * Human readable description abou the domain.
   * @type {string}
   * @memberof UpdateDomain
   */
  description?: string;
  /**
   * Enable or disable host vm auto-enrollment for this domain
   * @type {boolean}
   * @memberof UpdateDomain
   */
  auto_enrollment_enabled?: boolean;
  /**
   * A domain id
   * @type {string}
   * @memberof UpdateDomain
   */
  domain_id?: string;
  /**
   * A name of a domain (all lower-case)
   * @type {string}
   * @memberof UpdateDomain
   */
  domain_name: string;
  /**
   *
   * @type {DomainType}
   * @memberof UpdateDomain
   */
  domain_type: DomainType;
  /**
   *
   * @type {DomainIpa}
   * @memberof UpdateDomain
   */
  'rhel-idm'?: DomainIpa;
  /**
   *
   * @type {SigningKeys}
   * @memberof UpdateDomain
   */
  signing_keys?: SigningKeys;
}

/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Action to retrieve the host information for the host vm being enrolled.
     * @summary Get host vm information.
     * @param {string} fqdn The full qualified domain name of the host.
     * @param {HostConf} hostConf Required information to take the action.
     * @param {string} [xRhInsightsRequestId] Unique request id for distributing tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hostConf: async (fqdn: string, hostConf: HostConf, xRhInsightsRequestId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'fqdn' is not null or undefined
      assertParamExists('hostConf', 'fqdn', fqdn);
      // verify required parameter 'hostConf' is not null or undefined
      assertParamExists('hostConf', 'hostConf', hostConf);
      const localVarPath = `/host-conf/{fqdn}`.replace(`{${'fqdn'}}`, encodeURIComponent(String(fqdn)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-rh-identity required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Rh-Identity', configuration);

      if (xRhInsightsRequestId != null) {
        localVarHeaderParameter['X-Rh-Insights-Request-Id'] = String(xRhInsightsRequestId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(hostConf, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Use the one time use token to update the initial information for a rhel-idm domain.
     * @summary Update a domain.
     * @param {string} xRhInsightsRequestId Request id
     * @param {string} xRhIdmRegistrationToken One-time password to authenticate domain registration with ipa-hcc command.
     * @param {string} uuid uuid for the IPA domain.
     * @param {string} xRhIdmVersion ipa-hcc agent version
     * @param {Domain} domain Information for an IPA domain so it is updated from the ipa-hcc agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerDomain: async (
      xRhInsightsRequestId: string,
      xRhIdmRegistrationToken: string,
      uuid: string,
      xRhIdmVersion: string,
      domain: Domain,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xRhInsightsRequestId' is not null or undefined
      assertParamExists('registerDomain', 'xRhInsightsRequestId', xRhInsightsRequestId);
      // verify required parameter 'xRhIdmRegistrationToken' is not null or undefined
      assertParamExists('registerDomain', 'xRhIdmRegistrationToken', xRhIdmRegistrationToken);
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('registerDomain', 'uuid', uuid);
      // verify required parameter 'xRhIdmVersion' is not null or undefined
      assertParamExists('registerDomain', 'xRhIdmVersion', xRhIdmVersion);
      // verify required parameter 'domain' is not null or undefined
      assertParamExists('registerDomain', 'domain', domain);
      const localVarPath = `/domains/{uuid}/register`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-rh-identity required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Rh-Identity', configuration);

      if (xRhInsightsRequestId != null) {
        localVarHeaderParameter['X-Rh-Insights-Request-Id'] = String(xRhInsightsRequestId);
      }

      if (xRhIdmRegistrationToken != null) {
        localVarHeaderParameter['X-Rh-Idm-Registration-Token'] = String(xRhIdmRegistrationToken);
      }

      if (xRhIdmVersion != null) {
        localVarHeaderParameter['X-Rh-Idm-Version'] = String(xRhIdmVersion);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(domain, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update the initial information for a rhel-idm domain.
     * @summary Update a previously registered domain.
     * @param {string} xRhInsightsRequestId Request id
     * @param {string} uuid uuid for the IPA domain.
     * @param {string} xRhIdmVersion ipa-hcc agent version
     * @param {Domain} domain Information for an IPA domain so it is updated from the ipa-hcc agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDomain: async (
      xRhInsightsRequestId: string,
      uuid: string,
      xRhIdmVersion: string,
      domain: Domain,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xRhInsightsRequestId' is not null or undefined
      assertParamExists('updateDomain', 'xRhInsightsRequestId', xRhInsightsRequestId);
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('updateDomain', 'uuid', uuid);
      // verify required parameter 'xRhIdmVersion' is not null or undefined
      assertParamExists('updateDomain', 'xRhIdmVersion', xRhIdmVersion);
      // verify required parameter 'domain' is not null or undefined
      assertParamExists('updateDomain', 'domain', domain);
      const localVarPath = `/domains/{uuid}/update`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-rh-identity required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Rh-Identity', configuration);

      if (xRhInsightsRequestId != null) {
        localVarHeaderParameter['X-Rh-Insights-Request-Id'] = String(xRhInsightsRequestId);
      }

      if (xRhIdmVersion != null) {
        localVarHeaderParameter['X-Rh-Idm-Version'] = String(xRhIdmVersion);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(domain, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ActionsApiAxiosParamCreator(configuration);
  return {
    /**
     * Action to retrieve the host information for the host vm being enrolled.
     * @summary Get host vm information.
     * @param {string} fqdn The full qualified domain name of the host.
     * @param {HostConf} hostConf Required information to take the action.
     * @param {string} [xRhInsightsRequestId] Unique request id for distributing tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async hostConf(
      fqdn: string,
      hostConf: HostConf,
      xRhInsightsRequestId?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostConfResponseSchema>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.hostConf(fqdn, hostConf, xRhInsightsRequestId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Use the one time use token to update the initial information for a rhel-idm domain.
     * @summary Update a domain.
     * @param {string} xRhInsightsRequestId Request id
     * @param {string} xRhIdmRegistrationToken One-time password to authenticate domain registration with ipa-hcc command.
     * @param {string} uuid uuid for the IPA domain.
     * @param {string} xRhIdmVersion ipa-hcc agent version
     * @param {Domain} domain Information for an IPA domain so it is updated from the ipa-hcc agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async registerDomain(
      xRhInsightsRequestId: string,
      xRhIdmRegistrationToken: string,
      uuid: string,
      xRhIdmVersion: string,
      domain: Domain,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Domain>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.registerDomain(
        xRhInsightsRequestId,
        xRhIdmRegistrationToken,
        uuid,
        xRhIdmVersion,
        domain,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Update the initial information for a rhel-idm domain.
     * @summary Update a previously registered domain.
     * @param {string} xRhInsightsRequestId Request id
     * @param {string} uuid uuid for the IPA domain.
     * @param {string} xRhIdmVersion ipa-hcc agent version
     * @param {Domain} domain Information for an IPA domain so it is updated from the ipa-hcc agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateDomain(
      xRhInsightsRequestId: string,
      uuid: string,
      xRhIdmVersion: string,
      domain: Domain,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Domain>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomain(xRhInsightsRequestId, uuid, xRhIdmVersion, domain, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ActionsApiFp(configuration);
  return {
    /**
     * Action to retrieve the host information for the host vm being enrolled.
     * @summary Get host vm information.
     * @param {string} fqdn The full qualified domain name of the host.
     * @param {HostConf} hostConf Required information to take the action.
     * @param {string} [xRhInsightsRequestId] Unique request id for distributing tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hostConf(fqdn: string, hostConf: HostConf, xRhInsightsRequestId?: string, options?: any): AxiosPromise<HostConfResponseSchema> {
      return localVarFp.hostConf(fqdn, hostConf, xRhInsightsRequestId, options).then((request) => request(axios, basePath));
    },
    /**
     * Use the one time use token to update the initial information for a rhel-idm domain.
     * @summary Update a domain.
     * @param {string} xRhInsightsRequestId Request id
     * @param {string} xRhIdmRegistrationToken One-time password to authenticate domain registration with ipa-hcc command.
     * @param {string} uuid uuid for the IPA domain.
     * @param {string} xRhIdmVersion ipa-hcc agent version
     * @param {Domain} domain Information for an IPA domain so it is updated from the ipa-hcc agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerDomain(
      xRhInsightsRequestId: string,
      xRhIdmRegistrationToken: string,
      uuid: string,
      xRhIdmVersion: string,
      domain: Domain,
      options?: any
    ): AxiosPromise<Domain> {
      return localVarFp
        .registerDomain(xRhInsightsRequestId, xRhIdmRegistrationToken, uuid, xRhIdmVersion, domain, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update the initial information for a rhel-idm domain.
     * @summary Update a previously registered domain.
     * @param {string} xRhInsightsRequestId Request id
     * @param {string} uuid uuid for the IPA domain.
     * @param {string} xRhIdmVersion ipa-hcc agent version
     * @param {Domain} domain Information for an IPA domain so it is updated from the ipa-hcc agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDomain(xRhInsightsRequestId: string, uuid: string, xRhIdmVersion: string, domain: Domain, options?: any): AxiosPromise<Domain> {
      return localVarFp.updateDomain(xRhInsightsRequestId, uuid, xRhIdmVersion, domain, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI {
  /**
   * Action to retrieve the host information for the host vm being enrolled.
   * @summary Get host vm information.
   * @param {string} fqdn The full qualified domain name of the host.
   * @param {HostConf} hostConf Required information to take the action.
   * @param {string} [xRhInsightsRequestId] Unique request id for distributing tracing.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActionsApi
   */
  public hostConf(fqdn: string, hostConf: HostConf, xRhInsightsRequestId?: string, options?: AxiosRequestConfig) {
    return ActionsApiFp(this.configuration)
      .hostConf(fqdn, hostConf, xRhInsightsRequestId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Use the one time use token to update the initial information for a rhel-idm domain.
   * @summary Update a domain.
   * @param {string} xRhInsightsRequestId Request id
   * @param {string} xRhIdmRegistrationToken One-time password to authenticate domain registration with ipa-hcc command.
   * @param {string} uuid uuid for the IPA domain.
   * @param {string} xRhIdmVersion ipa-hcc agent version
   * @param {Domain} domain Information for an IPA domain so it is updated from the ipa-hcc agent.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActionsApi
   */
  public registerDomain(
    xRhInsightsRequestId: string,
    xRhIdmRegistrationToken: string,
    uuid: string,
    xRhIdmVersion: string,
    domain: Domain,
    options?: AxiosRequestConfig
  ) {
    return ActionsApiFp(this.configuration)
      .registerDomain(xRhInsightsRequestId, xRhIdmRegistrationToken, uuid, xRhIdmVersion, domain, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update the initial information for a rhel-idm domain.
   * @summary Update a previously registered domain.
   * @param {string} xRhInsightsRequestId Request id
   * @param {string} uuid uuid for the IPA domain.
   * @param {string} xRhIdmVersion ipa-hcc agent version
   * @param {Domain} domain Information for an IPA domain so it is updated from the ipa-hcc agent.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActionsApi
   */
  public updateDomain(xRhInsightsRequestId: string, uuid: string, xRhIdmVersion: string, domain: Domain, options?: AxiosRequestConfig) {
    return ActionsApiFp(this.configuration)
      .updateDomain(xRhInsightsRequestId, uuid, xRhIdmVersion, domain, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ResourcesApi - axios parameter creator
 * @export
 */
export const ResourcesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create a domain in the current organization.
     * @summary Create a domain.
     * @param {CreateDomain} createDomain Domain object to be created.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDomain: async (createDomain: CreateDomain, xRhInsightsRequestId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createDomain' is not null or undefined
      assertParamExists('createDomain', 'createDomain', createDomain);
      const localVarPath = `/domains`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-rh-identity required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Rh-Identity', configuration);

      if (xRhInsightsRequestId != null) {
        localVarHeaderParameter['X-Rh-Insights-Request-Id'] = String(xRhInsightsRequestId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createDomain, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete an existing domain from the current organization.
     * @summary Delete domain.
     * @param {string} uuid The uuid that identify the domain.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDomain: async (uuid: string, xRhInsightsRequestId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('deleteDomain', 'uuid', uuid);
      const localVarPath = `/domains/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-rh-identity required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Rh-Identity', configuration);

      if (xRhInsightsRequestId != null) {
        localVarHeaderParameter['X-Rh-Insights-Request-Id'] = String(xRhInsightsRequestId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * For the current organization, list all the domains that are being managed from console.dot
     * @summary List domains in the organization
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {number} [offset] pagination offset
     * @param {number} [limit] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDomains: async (xRhInsightsRequestId?: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/domains`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-rh-identity required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Rh-Identity', configuration);

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (xRhInsightsRequestId != null) {
        localVarHeaderParameter['X-Rh-Insights-Request-Id'] = String(xRhInsightsRequestId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Request the information for a specific domain of our organization.
     * @summary Read a domain.
     * @param {string} uuid The uuid that identify the domain.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readDomain: async (uuid: string, xRhInsightsRequestId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('readDomain', 'uuid', uuid);
      const localVarPath = `/domains/{uuid}`.replace(`{${'uuid'}}`, encodeURIComponent(String(uuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication x-rh-identity required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Rh-Identity', configuration);

      if (xRhInsightsRequestId != null) {
        localVarHeaderParameter['X-Rh-Insights-Request-Id'] = String(xRhInsightsRequestId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ResourcesApi - functional programming interface
 * @export
 */
export const ResourcesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ResourcesApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a domain in the current organization.
     * @summary Create a domain.
     * @param {CreateDomain} createDomain Domain object to be created.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createDomain(
      createDomain: CreateDomain,
      xRhInsightsRequestId?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Domain>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createDomain(createDomain, xRhInsightsRequestId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Delete an existing domain from the current organization.
     * @summary Delete domain.
     * @param {string} uuid The uuid that identify the domain.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteDomain(
      uuid: string,
      xRhInsightsRequestId?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDomain(uuid, xRhInsightsRequestId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * For the current organization, list all the domains that are being managed from console.dot
     * @summary List domains in the organization
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {number} [offset] pagination offset
     * @param {number} [limit] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listDomains(
      xRhInsightsRequestId?: string,
      offset?: number,
      limit?: number,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDomainsResponseSchema>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listDomains(xRhInsightsRequestId, offset, limit, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Request the information for a specific domain of our organization.
     * @summary Read a domain.
     * @param {string} uuid The uuid that identify the domain.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readDomain(
      uuid: string,
      xRhInsightsRequestId?: string,
      options?: AxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Domain>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.readDomain(uuid, xRhInsightsRequestId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * ResourcesApi - factory interface
 * @export
 */
export const ResourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ResourcesApiFp(configuration);
  return {
    /**
     * Create a domain in the current organization.
     * @summary Create a domain.
     * @param {CreateDomain} createDomain Domain object to be created.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDomain(createDomain: CreateDomain, xRhInsightsRequestId?: string, options?: any): AxiosPromise<Domain> {
      return localVarFp.createDomain(createDomain, xRhInsightsRequestId, options).then((request) => request(axios, basePath));
    },
    /**
     * Delete an existing domain from the current organization.
     * @summary Delete domain.
     * @param {string} uuid The uuid that identify the domain.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDomain(uuid: string, xRhInsightsRequestId?: string, options?: any): AxiosPromise<void> {
      return localVarFp.deleteDomain(uuid, xRhInsightsRequestId, options).then((request) => request(axios, basePath));
    },
    /**
     * For the current organization, list all the domains that are being managed from console.dot
     * @summary List domains in the organization
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {number} [offset] pagination offset
     * @param {number} [limit] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDomains(xRhInsightsRequestId?: string, offset?: number, limit?: number, options?: any): AxiosPromise<ListDomainsResponseSchema> {
      return localVarFp.listDomains(xRhInsightsRequestId, offset, limit, options).then((request) => request(axios, basePath));
    },
    /**
     * Request the information for a specific domain of our organization.
     * @summary Read a domain.
     * @param {string} uuid The uuid that identify the domain.
     * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readDomain(uuid: string, xRhInsightsRequestId?: string, options?: any): AxiosPromise<Domain> {
      return localVarFp.readDomain(uuid, xRhInsightsRequestId, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * ResourcesApi - object-oriented interface
 * @export
 * @class ResourcesApi
 * @extends {BaseAPI}
 */
export class ResourcesApi extends BaseAPI {
  /**
   * Create a domain in the current organization.
   * @summary Create a domain.
   * @param {CreateDomain} createDomain Domain object to be created.
   * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public createDomain(createDomain: CreateDomain, xRhInsightsRequestId?: string, options?: AxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .createDomain(createDomain, xRhInsightsRequestId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete an existing domain from the current organization.
   * @summary Delete domain.
   * @param {string} uuid The uuid that identify the domain.
   * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public deleteDomain(uuid: string, xRhInsightsRequestId?: string, options?: AxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .deleteDomain(uuid, xRhInsightsRequestId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * For the current organization, list all the domains that are being managed from console.dot
   * @summary List domains in the organization
   * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
   * @param {number} [offset] pagination offset
   * @param {number} [limit] Number of items per page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public listDomains(xRhInsightsRequestId?: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .listDomains(xRhInsightsRequestId, offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Request the information for a specific domain of our organization.
   * @summary Read a domain.
   * @param {string} uuid The uuid that identify the domain.
   * @param {string} [xRhInsightsRequestId] Request id for distributed tracing.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public readDomain(uuid: string, xRhInsightsRequestId?: string, options?: AxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .readDomain(uuid, xRhInsightsRequestId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
